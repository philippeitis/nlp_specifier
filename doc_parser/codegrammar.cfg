S -> MRET | RETIF | HASSERT | QASSERT | SIDE | FNCALL

## "Atomic" elements
MNN -> NN | NNS
# the same, same, equal etc
TJJ -> DT JJ | DT JJR | JJ | JJR
# adjective + modifiers
MJJ -> RB JJ | JJ
# Meta-Verb (verb forms + modifiers)
MVB -> RB VB | VB | RB VBZ | VBZ | RB VBP | VBP | RB VBN | VBN
# if and only if
IFF -> IF CC RB IF
# than or equal to
EQTO -> IN CC JJ IN

# Basic operations.
BITOP -> JJ CC
# Subtracts 2 from a
# Adds 2 to a
# a added to b
# a is added to b
# adds 2 to a
# adds 2 and a together
ARITHOP -> ARITH IN | ARITH
SHIFTOP -> SHIFT IN DT NN IN | JJ SHIFT
OP -> BITOP | ARITHOP | SHIFTOP

# Objects
OBJ -> PRP | DT MNN | MNN | CODE | LIT | DT LIT | OBJ OP OBJ | DT MNN IN OBJ | FNCALL | DT FNCALL


## Ranges
RSEP -> CC | IN
# index `i` from 0 to `self.len()`
RANGE -> OBJ IN OBJ RSEP OBJ | IN OBJ RSEP OBJ | IN IN OBJ
# *identifer* from start to end | up to 'max' (IN IN OBJ) - no start variable or identifier.
RANGEMOD -> RANGE | RANGE COMMA JJ | RANGE JJ

## Simple comparisons and properties
# Relationship: eg. less than object
REL -> TJJ IN OBJ | TJJ EQTO OBJ | IN OBJ | REL CC OBJ
# Rel + modifiers
MREL -> RB REL | REL
# is adjective, is relation, is a literal (eg. ==)
PROP -> MVB MJJ | MVB MREL | MVB OBJ | MVB | MVB RANGEMOD

## Predicates (for single objects, objects in ranges, and quantified objects).
# object has property -> object is red
ASSERT -> OBJ PROP | OBJ CC ASSERT
# Object must have property (or object and object must have property)
HASSERT -> OBJ MD PROP | OBJ CC HASSERT
# If object has property, if and only if object has property
# BOOL_LIT?
PRED -> IF ASSERT | IFF ASSERT | IF CODE | IFF CODE | IF FNCALL | IFF FNCALL
#        for some object
QUANT -> FOR DT OBJ
# RANGE + modifier (eg. "range, exclusive")
FOREACH -> QUANT | QUANT RANGEMOD | FOREACH CC MREL | FOREACH MREL
# For each value, object must have property
QASSERT -> FOREACH COMMA HASSERT | FOREACH HASSERT | HASSERT FOREACH | CODE FOREACH
QPRED -> IF QASSERT | IFF QASSERT

## Return operations
# obj in the collection
MRET -> RET OBJ | OBJ VBZ RET | OBJ RET
# Return obj if predicate
RETIF -> MRET PRED | MRET QPRED | QPRED MRET | PRED MRET | RETIF RB RETIF | RETIF RB OBJ

#       object is verbed to object | object verbed | object is verbed | obj is right shifted by n
SIDE -> OBJ VBZ MVB IN OBJ | OBJ VBZ MVB | OBJ VBZ MJJ MVB IN OBJ
# Object verbed - eg. `a` is negated, `a`
OBJV -> OBJ MVB | OBJ VBZ MVB

# Translate from one CFG to another
PRP -> "PRP"
DT -> "DT"
NN -> "NN"
NNS -> "NNS"
CODE -> "CODE"
JJR -> "JJR"
IN -> "IN"
VBP -> "VBP"
VBZ -> "VBZ"
JJ -> "JJ"
CC -> "CC"
RB -> "RB"
RET -> "RET"
LIT -> "LIT"
DOT -> "."
COMMA -> ","
MD -> "MD"
VB -> "VB"
FOR -> "FOR"
VBN -> "VBN"
IF -> "IF" | "if_IN"

ARITH -> "ARITH"
SHIFT -> "SHIFT"
# swap a, b
