S -> RETIF | IFRET | HASSERT | QASSERT

# Objects
OBJ -> PRP | DT NN | CODE | LIT | MNN
# Relationship: eg. less than object
REL -> TJJ IN OBJ | TJJ EQTO OBJ
# the same, same, equal etc
TJJ -> DT JJ | DT JJR | JJ | JJR
# than or equal to
EQTO -> IN CC JJ IN
# is adjective, is relation, is a literal (eg. ==)
PROP -> MVB MJJ | MVB MREL | MVB LIT | MVB
# Meta-Verb (verb forms + modifiers)
MVB -> RB VB | VB | RB VBZ | VBZ | RB VBP | VBP
# adjective + modifiers
MJJ -> RB JJ | JJ
# Rel + modifiers
MREL -> RB REL | REL
# object has property -> object is red
ASSERT -> OBJ PROP
# Object must have property
HASSERT -> OBJ MD PROP
# For each value, object must have property
QASSERT -> FOREACH COMMA HASSERT | FOREACH HASSERT | HASSERT FOREACH | CODE FOREACH
# If object has property, if and only if object has property
PRED -> IN ASSERT | IFF ASSERT
QPRED -> IN QASSERT | IFF QASSERT
# if and only if
IFF -> IN CC RB IN
# obj in the collection
#        for some object
QUANT -> FOR DT OBJ
# Return obj if predicate
RETIF -> RET OBJ PRED | RET OBJ QPRED
# If predicate, return object
IFRET -> PRED RET OBJ | PRED COMMA RET OBJ
# *identifer* from start to end
RANGE -> OBJ IN OBJ RSEP OBJ
RSEP -> CC | IN
MNN -> NN | NNS
# For each object ...
#          for each index `i` from 0 to `self.len()`
FOREACH -> QUANT | QUANT RANGE | QUANT RANGE COMMA JJ | QUANT RANGE JJ  | FOREACH CC MREL

# Translate from one CFG to another
PRP -> "PRP"
DT -> "DT"
NN -> "NN"
NNS -> "NNS"
CODE -> "CODE"
JJR -> "JJR"
IN -> "IN"
VBP -> "VBP"
VBZ -> "VBZ"
JJ -> "JJ"
CC -> "CC"
RB -> "RB"
RET -> "RET"
LIT -> "LIT"
DOT -> "."
COMMA -> ","
MD -> "MD"
VB -> "VB"
FOR -> "FOR"
