S -> MRET | RETIF | HASSERT | QASSERT | SIDE | FNCALL

## "Atomic" elements
MNN -> NN | NNS | NNP | NNPS
# the same, same, equal etc
TJJ -> DT JJ | DT JJR | JJ | JJR | DT JJS | JJS
# adjective + modifiers
MJJ -> RB JJ | JJ | RB JJR | JJR | RB JJS | JJS
# Meta-Verb (verb forms + modifiers)
MVB -> RB VB | VB | RB VBZ | VBZ | RB VBP | VBP | RB VBN | VBN | RB VBG | VBG | RB VBD | VBD
# if and only if
IFF -> IF CC RB IF
# than or equal to
EQTO -> IN CC JJ IN

# Basic operations.
BITOP -> JJ CC
# Subtracts 2 from a
# Adds 2 to a
# a added to b
# a is added to b
# adds 2 to a
# adds 2 and a together
ARITHOP -> ARITH IN | ARITH
SHIFTOP -> SHIFT IN DT NN IN | JJ SHIFT
OP -> BITOP | ARITHOP | SHIFTOP

# Objects
OBJ -> PRP | DT MNN | MNN | CODE | LIT | DT LIT | OBJ OP OBJ | FNCALL | DT FNCALL | STR | CHAR | DT VBG MNN | PROP_OF OBJ

## Ranges
RSEP -> CC | IN
# index `i` from 0 to `self.len()`
RANGE -> OBJ IN OBJ RSEP OBJ | IN OBJ RSEP OBJ | IN IN OBJ
# *identifer* from start to end | up to 'max' (IN IN OBJ) - no start variable or identifier.
RANGEMOD -> RANGE | RANGE COMMA JJ | RANGE JJ

## Simple comparisons and properties
# Relationship: eg. less than object
REL -> TJJ IN OBJ | TJJ EQTO OBJ | IN OBJ | REL CC OBJ
# Rel + modifiers
MREL -> RB REL | REL
# is adjective, is relation, is a literal (eg. ==)
PROP -> MVB MJJ | MVB MREL | MVB OBJ | MVB | MVB RANGEMOD
# the val of an (obj)
PROP_OF -> DT MNN IN DT | DT MNN IN | DT MJJ IN | DT MJJ IN DT
## Predicates (for single objects, objects in ranges, and quantified objects).
# object has property -> object is red
ASSERT -> OBJ PROP | OBJ CC ASSERT
# Object must have property (or object and object must have property)
HASSERT -> OBJ MD PROP | OBJ CC HASSERT
# If object has property, if and only if object has property
#        for some object
QUANT -> FOR DT OBJ
# RANGE + modifier (eg. "range, exclusive")
FOREACH -> QUANT | QUANT RANGEMOD | FOREACH CC MREL | FOREACH MREL
# For each value, object must have property
QASSERT -> FOREACH COMMA HASSERT | FOREACH HASSERT | HASSERT FOREACH | CODE FOREACH

## Return operations
# obj in the collection
MRET -> RET OBJ | OBJ VBZ RET | OBJ RET
# BOOL_LIT?
BOOL_EXPR -> ASSERT | QASSERT | CODE | FNCALL
COND -> IF BOOL_EXPR | IFF BOOL_EXPR
# Return obj if predicate
RETIF -> MRET COND | COND COMMA MRET | RETIF COMMA RB RETIF | RETIF COMMA RB OBJ

#       object is verbed to object | object verbed | object is verbed | obj is right shifted by n | Prints {some item} from source (and returns)
SIDE -> OBJ VBZ MVB IN OBJ | OBJ VBZ MVB | OBJ VBZ MJJ MVB IN OBJ | VBZ TJJ OBJ IN OBJ CC MRET
# Object verbed - eg. `a` is negated, `a`
OBJV -> OBJ MVB | OBJ VBZ MVB

# Translate from one CFG to another
NN -> "NN"
NNS -> "NNS"
NNP -> "NNP"
NNPS -> "NNPS"

VB -> "VB"
VBP -> "VBP"
VBZ -> "VBZ"
VBN -> "VBN"
VBG -> "VBG"
VBD -> "VBD"

JJ -> "JJ"
JJR -> "JJR"
JJS -> "JJS"

RB -> "RB"

PRP -> "PRP"
DT -> "DT"
IN -> "IN"
CC -> "CC"
MD -> "MD"

RET -> "RET"
CODE -> "CODE"
LIT -> "LIT"
IF -> "IF" | "if_IN"
FOR -> "FOR"

DOT -> "DOT"
COMMA -> "COMMA"
EXCL -> "EXCL"

ARITH -> "ARITH"
SHIFT -> "SHIFT"

# TODO: Find usages for below
# "POS": 's "PRP$" its "PDT" all
# Support for links in item
WDT -> "WDT"
LRB -> "-LRB-"
RRB -> "-RRB-"
HYPH -> "HYPH"
CD -> "CD"
X -> ":" | "WRB" | "TO" | "WP" | "NFP" | "FW" | "XX" | "SYM" | "RBR" | "POS" | "PRP$" | "PDT" | "UH" | "LS" | "ADD" | "RP" | "``" | "''" | "$"
STR -> "STR"
CHAR -> "CHAR"
# swap a, b

#            _u??          _i??       _f??       xx        xx.
# LIT_NUM -> LIT_UNUM | LIT_INUM | LIT_FNUM | LIT_INT | LIT_FLOAT
# LIT_UNUM -> LIT_u8 | LIT_u16 | LIT_u32 | LIT_u64 | LIT_u128 | LIT_usize
# LIT_INUM -> LIT_i8 | LIT_i16 | LIT_i32 | LIT_i64 | LIT_i128 | LIT_isize
# LIT_FNUM -> LIT_f32 | LIT_f64
#
# LIT -> LIT_BOOL | LIT_NUM | LIT_STR | LIT_CHAR
# IDENT -> "ident"